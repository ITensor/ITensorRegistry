name: Auto-merge registrator PRs after 10 minutes

on:
  pull_request_target:
    types: [opened, reopened, synchronize, ready_for_review]
  issue_comment:
    types: [created]
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: write

concurrency:
  group: timed-automerge-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  merge:
    # Only run for PR events, or PR comments that contain "Commit:"
    if: >
      github.event_name == 'pull_request_target' ||
      (github.event.issue.pull_request != null && contains(github.event.comment.body, 'Commit:'))
    runs-on: ubuntu-latest
    steps:
      - uses: julia-actions/setup-julia@v2
        with:
          version: "1"

      - name: Merge after 10 minutes if PR matches format
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}

          MIN_AGE_MINUTES: "10"
          ALLOWED_AUTHORS: "mtfishman"          # comma-separated; set "" to allow anyone
          HEAD_PREFIX: "registrator/"           # set "" to disable

          TITLE_REGEX: '^New version:\s+.+\sv[0-9]'
          COMMIT_REGEX: '(?m)^Commit:\s*[0-9a-f]{7,40}\s*$'

          MERGE_METHOD: "squash"                # squash | merge | rebase
          DELETE_BRANCH: "true"
        run: |
          julia <<'JL'
          using Dates, Base64

          sh(cmd) = chomp(read(cmd, String))
          repo = ENV["REPO"]
          pr   = parse(Int, ENV["PR_NUMBER"])

          min_age = Minute(parse(Int, get(ENV,"MIN_AGE_MINUTES","10")))
          allowed = filter(!isempty, strip.(split(get(ENV,"ALLOWED_AUTHORS",""), ',')))
          head_prefix = get(ENV,"HEAD_PREFIX","")
          title_re  = Regex(get(ENV,"TITLE_REGEX","^New version:"))
          commit_re = Regex(get(ENV,"COMMIT_REGEX","(?m)^Commit:"))
          method = get(ENV,"MERGE_METHOD","squash")
          del_branch = get(ENV,"DELETE_BRANCH","true") == "true"

          jq = "[.state, (.draft|tostring), .title, .user.login, .base.ref, .head.ref, .head.repo.full_name, .created_at, .head.sha, (.body // \"\" | @base64)] | @tsv"

          function meta()
            f = split(sh(`gh api repos/$repo/pulls/$pr --jq $jq`), '\t'; keepempty=true)
            state,draft,title,author,base,head,head_repo,created,sha,body64 = f
            body = String(base64decode(body64))
            return (; state,draft,title,author,base,head,head_repo,created,sha,body)
          end

          function eligible(m)
            m.state == "open" || return false
            m.draft == "false" || return false
            m.base == "main" || return false
            m.head_repo == repo || return false
            isempty(allowed) || (m.author in allowed) || return false
            isempty(head_prefix) || startswith(m.head, head_prefix) || return false
            occursin(title_re, m.title) || return false
            occursin(commit_re, m.body) || return false
            return true
          end

          m = meta()
          eligible(m) || (println("PR #$pr not eligible; exiting."); exit(0))

          created = split(replace(m.created, "Z"=>""), ".")[1]
          created_dt = DateTime(created, dateformat"yyyy-mm-ddTHH:MM:SS")
          wait_ms = Dates.value((created_dt + min_age) - now())
          wait_ms > 0 && sleep(ceil(Int, wait_ms/1000))

          m = meta()
          eligible(m) || (println("PR #$pr no longer eligible; exiting."); exit(0))

          run(`gh api -X PUT repos/$repo/pulls/$pr/merge -f merge_method=$method -f sha=$(m.sha)`)

          if del_branch
            enc = replace(m.head, "/" => "%2F")
            try run(`gh api -X DELETE repos/$repo/git/refs/heads/$enc`) catch; end
          end
          JL
